<!-- Ten Minute Physics - [08] CannonBall 3D - Interaction -->

<!DOCTYPE html>
    <head>
        <title>CannonBall 3D - Interaction</title>
        <style>
            body {
                font-family: Verdana,serif;
                font-size: 15px;
            }
        </style>
    </head>
    
    <body>
        <h1>CannonBall 3D - Interaction</h1>
        <button id = "buttonRun" onclick="run()">Run</button>
        <button onclick="restart()">Restart</button>
        
        <br><br>
        <div id="container"></div>
        
        <!-- Ref three library for 3d -->
        <script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
        <script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
        
        <script src="Framework/PhysicsWorld.js"></script>
        <script src="Algorithms/Grabber.js"></script>
    
        <script>
            let gPhysicsScene = {
                gravity : new THREE.Vector3( 0.0, -10.0, 0.0 ),
                numSubsteps : 1.0,
                dt : 1.0 / 60.0,
                worldSize : { x: 1.5, z: 2.5 },
                paused: true,
                objects: [],
            }

            class CannonBallWorld extends PhysicsWorldBase {
                initPhysics() {
                    let radius = 0.2;
                    let pos = new THREE.Vector3( radius, radius, radius );
                    let vel = new THREE.Vector3( 2.0, 5.0, 3.0 );

                    this.PhysicsScene.objects.push(new Ball( pos, radius, vel, this.ThreeScene ));
                }                
            }
        
            class Ball {
                static Layer = 1;
                
                constructor(pos, radius, vel, scene) {
                    // physics data
                    this.pos = pos;
                    this.radius = radius;
                    this.vel = vel;
                    this.grabbed = false;
        
                    // visual mesh
                    let geometry = new THREE.SphereGeometry( radius, 32, 32 );
                    let material = new THREE.MeshPhongMaterial( { color: 0xff0000 } );
                    this.visMesh = new THREE.Mesh( geometry, material );
                    this.visMesh.position.copy(pos);

                    // for ray casting
                    this.visMesh.userData = this;
                    this.visMesh.layers.enable(Ball.Layer);

                    scene.add( this.visMesh );
                }
        
                simulate(dt, gravity) {
                    if (this.grabbed)
                        return;

                    let ps = gPhysicsScene;
                    
                    // calculate vel
                    this.vel.addScaledVector( ps.gravity, ps.dt );
                    // calculate pos
                    this.pos.addScaledVector( this.vel, ps.dt );
        
                    // border on x coordinate
                    if (this.pos.x < -ps.worldSize.x) {
                        this.pos.x = -ps.worldSize.x;
                        this.vel.x = -this.vel.x;
                    }
        
                    if (this.pos.x > ps.worldSize.x) {
                        this.pos.x = ps.worldSize.x;
                        this.vel.x = -this.vel.x;
                    }
        
                    // border on z coordinate
                    if (this.pos.z < -ps.worldSize.z) {
                        this.pos.z = -ps.worldSize.z;
                        this.vel.z = -this.vel.z;
                    }
        
                    if (this.pos.z > ps.worldSize.z) {
                        this.pos.z = ps.worldSize.z;
                        this.vel.z = -this.vel.z;
                    }
        
                    // border on y coordinate
                    if (this.pos.y < this.radius) {
                        this.pos.y = this.radius;
                        this.vel.y = -this.vel.y;
                    }
        
                    // flush visMesh.position
                    this.visMesh.position.copy(this.pos);
                    this.visMesh.geometry.computeBoundingSphere();
                }
        
                startGrab(pos)
                {
                    this.grabbed = true;
                    this.pos.copy(pos);
                    this.visMesh.position.copy(pos);
                }
        
                moveGrabbed(pos, vel)
                {
                    this.pos.copy(pos);
                    this.visMesh.position.copy(pos);
                }
        
                endGrab(pos, vel)
                {
                    this.grabbed = false;
                    this.vel.copy(vel);
                }
            }
        
            function run() {
                gWorld.run();
            }
        
            function restart() {
                gWorld.restart();
            }
        
            registerWorld(new CannonBallWorld(gPhysicsScene, container, true));
        
        </script>
    </body>