<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<html lang="en">
    <head>
        <title>Soft Body Simulation</title>
        <style>
            body {
                font-family: verdana, serif;
                font-size: 15px;
            }
            .button {
                background-color: #606060;
                border: none;
                color: white;
                padding: 15px 32px;
                font-size: 16px;
                margin: 4px 2px;
                cursor: pointer;
            }
        </style>
    </head>
    
    <body>
    
    <h1>Soft Body Simulation</h1>
        <button id = "buttonRun" onclick="run()" class="button">Run</button>
        <button onclick="restart()" class="button">Restart</button>
        <button onclick="squash()" class="button">Squash</button>
        <label>
            <input type = "checkbox" onclick = "onShowTets()">
            Show tets
        </label><br>
        
        <span id = "numTets">0</span> tets&nbsp;&nbsp;
        <span id = "numTris">0</span> tris&nbsp;&nbsp;
        <span id = "numVerts">0</span> verts&nbsp;&nbsp;
        
        <label>
            Compliance:
            <input type = "range" min = "0" max = "10" value = "0" id = "complianceSlider" class = "slider">
        </label>
        
        <br><br>
        <div id="container"></div>
        
        <script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
        <script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>

        <script src="../../../Engine/Algorithms/MathMethods.js"></script>
        <script src="../../../Engine/Algorithms/DenseHash.js"></script>
        <script src="../../../Engine/Algorithms/Grabber.js"></script>
        <script src="../../../Engine/Physics/Constraints.js"></script>
        <script src="../../../Engine/Framework/PhysicsWorld.js"></script>
        <script src="../../../Engine/Framework/PhysicsObject.js"></script>
        <script src="../../GeometryData/[12] SoftBodySkinningData.js"></script>
    
        <script>
            let gPhysicsScene = {
                    gravity : [0.0, -10.0, 0.0],
                    dt : 1.0 / 60.0,
                    numSubsteps : 10,
                    paused: true,
                    showTets : false,
                    objects: [],
            };
        
            class SoftBodyWorld extends PhysicsWorldBase {
                initPhysics() {
                    let body = new SoftBody(dragonTetMesh, dragonVisMesh, this.ThreeScene);
                    this.BodyNumTets = body.numTets;
                    
                    this.setTargetLayer(SoftBody.Layer);
                    this.PhysicsScene.objects.push(body);
                }
                
                initUI() {
                    document.getElementById("numTets").innerHTML = this.BodyNumTets;
                    document.getElementById("numTris").innerHTML = (dragonVisMesh.triIds.length / 3).toString();
                    document.getElementById("numVerts").innerHTML = (dragonVisMesh.verts.length / 3).toString();                    
                }
            }
            
            class SoftBody extends PhysicsObjectGrabable {
                static Layer = 1;
                
                constructor(tetMesh, visMesh, scene, edgeCompliance = 0.0, volCompliance = 0.0) {
                    super();
                    
                    // physics
                    this.numParticles = tetMesh.verts.length / 3;
                    this.numTets = tetMesh.tetIds.length / 4;
                    this.pos = new Float32Array(tetMesh.verts);
                    this.prevPos = tetMesh.verts.slice();
                    this.vel = new Float32Array(3 * this.numParticles);
        
                    this.tetIds = tetMesh.tetIds;
                    this.edgeIds = tetMesh.edgeIds;
                    this.restVol = new Float32Array(this.numTets);
                    this.edgeLengths = new Float32Array(this.edgeIds.length / 2);
                    this.invMass = new Float32Array(this.numParticles);
        
                    this.edgeCompliance = edgeCompliance;
                    this.volCompliance = volCompliance;
        
                    this.initPhysics();
        
                    // create simplified tet mesh
                    let geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(this.pos, 3));
                    geometry.setIndex(tetMesh.edgeIds);
                    let lineMaterial = new THREE.LineBasicMaterial({color: 0xffffff, linewidth: 2});
                    this.tetMesh = new THREE.LineSegments(geometry, lineMaterial);
                    this.tetMesh.visible = true;
                    scene.add(this.tetMesh);
                    this.tetMesh.visible = false;
        
                    // create visual(high precise) embedded mesh
                    this.numVisVerts = visMesh.verts.length / 3;
                    this.skinningInfo = new Float32Array(4 * this.numVisVerts);
                    this.computeSkinningInfo(visMesh.verts);
        
                    geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(
                        new Float32Array(3 * this.numVisVerts), 3));
                    geometry.setIndex(visMesh.triIds);
                    let visMaterial = new THREE.MeshPhongMaterial({color: 0xf78a1d});
                    this.visMesh = new THREE.Mesh(geometry, visMaterial);
                    this.visMesh.castShadow = true;
                    this.visMesh.userData = this;	// for raycasting
                    this.visMesh.layers.enable(1);
                    scene.add(this.visMesh);
                    geometry.computeVertexNormals();
                    this.updateVisMesh();
                }
        
                // compute barycentric coords for each visual mesh's vertices
                computeSkinningInfo(visVerts) {
                    // create a hash for all vertices of the visual mesh
                    let hash = new DenseHash(0.05, this.numVisVerts);
                    hash.update(visVerts);
        
                    this.skinningInfo.fill(-1.0);		// undefined
        
                    let minDist = new Float32Array(this.numVisVerts);
                    minDist.fill(Number.MAX_VALUE);
                    let border = 0.05;
        
                    // each tet searches for containing vertices
        
                    let tetCenter = new Float32Array(3);
                    let mat = new Float32Array(9);
                    let bary = new Float32Array(4);
        
                    for (let i = 0; i < this.numTets; i++) {
        
                        // compute bounding sphere of tet
                        tetCenter.fill(0.0);
                        for (let j = 0; j < 4; j++)
                            vecAdd(tetCenter, 0, this.pos, this.tetIds[4 * i + j], 0.25);
        
                        let rMax = 0.0;
                        for (let j = 0; j < 4; j++) {
                            let r2 = vecDistSquared(tetCenter, 0, this.pos, this.tetIds[4 * i + j]);
                            rMax = Math.max(rMax, Math.sqrt(r2));
                        }
        
                        rMax += border;
        
                        hash.query(tetCenter, 0, rMax);
                        if (hash.queryIds.length === 0)
                            continue;
        
                        let id0 = this.tetIds[4 * i];
                        let id1 = this.tetIds[4 * i + 1];
                        let id2 = this.tetIds[4 * i + 2];
                        let id3 = this.tetIds[4 * i + 3];
        
                        vecSetDiff(mat, 0, this.pos, id0, this.pos, id3);
                        vecSetDiff(mat, 1, this.pos, id1, this.pos, id3);
                        vecSetDiff(mat, 2, this.pos, id2, this.pos, id3);
        
                        matSetInverse(mat);
        
                        for (let j = 0; j < hash.queryIds.length; j++) {
                            let id = hash.queryIds[j];
        
                            // we already have skinning info
                            if (minDist[id] <= 0.0)
                                continue;
        
                            if (vecDistSquared(visVerts, id, tetCenter, 0) > rMax * rMax)
                                continue;
        
                            // compute barycentric coords for candidate
                            vecSetDiff(bary,0, visVerts,id, this.pos, id3);
                            matSetMult(mat, bary,0, bary,0);
                            bary[3] = 1.0 - bary[0] - bary[1] - bary[2];
        
                            let dist = 0.0;
                            for (let k = 0; k < 4; k++)
                                dist = Math.max(dist, -bary[k]);
        
                            if (dist < minDist[id]) {
                                minDist[id] = dist;
                                // the tet vertices start index(0, 1, 2, 3) which visual mesh's vertices attached on
                                this.skinningInfo[4 * id] = i;
                                // barycentric coordinates for current attachment
                                this.skinningInfo[4 * id + 1] = bary[0];
                                this.skinningInfo[4 * id + 2] = bary[1];
                                this.skinningInfo[4 * id + 3] = bary[2];
                            }
                        }
                    }
                }
        
                initPhysics() {
                    this.invMass.fill(0.0);
                    this.restVol.fill(0.0);

                    // calc inverse mass volume value of tetrahedron
                    for (let i = 0; i < this.numTets; i++) {
                        // here ρ=1 by default, so that mass equal to volume
                        let vol = Constraints.getTetVolume(this.pos, this.tetIds, i);
                        this.restVol[i] = vol;
                        let pInvMass = vol > 0.0 ? 1.0 / (vol / 4.0) : 0.0;

                        // every single point will link multi tetrahedrons, so add inverse mass value
                        this.invMass[this.tetIds[4 * i]] += pInvMass;
                        this.invMass[this.tetIds[4 * i + 1]] += pInvMass;
                        this.invMass[this.tetIds[4 * i + 2]] += pInvMass;
                        this.invMass[this.tetIds[4 * i + 3]] += pInvMass;
                    }

                    // calc length of edge
                    for (let i = 0; i < this.edgeLengths.length; i++) {
                        let id0 = this.edgeIds[2 * i];
                        let id1 = this.edgeIds[2 * i + 1];
                        this.edgeLengths[i] = Math.sqrt(vecDistSquared(this.pos,id0, this.pos,id1));
                    }
                }

                preSolve(dt, gravity) {
                    for (let i = 0; i < this.numParticles; i++) {
                        // don't need to move for one's mass is infinite
                        if (this.invMass[i] === 0.0)
                            continue;

                        // XPBD - step 1
                        // - calc velocity with g and dt
                        // - save previous position with current
                        // - calc new position with new velocity
                        vecAdd(this.vel,i, gravity,0, dt);
                        vecCopy(this.prevPos,i, this.pos,i);
                        vecAdd(this.pos,i, this.vel,i, dt);

                        // handle down border
                        let y = this.pos[3 * i + 1];
                        if (y < 0.0) {
                            vecCopy(this.pos,i, this.prevPos,i);
                            this.pos[3 * i + 1] = 0.0;
                        }
                    }
                }
        
                solve(dt) {
                    // XPBD - step 2
                    // handle constraints
                    // for 3d model: edge / volume
                    // for 2d: edge
                    // 
                    // one distance constraint per edge
                    // one volume constraint per tetrahedron
                    Constraints.solveEdges(this.pos, this.edgeLengths, this.edgeIds, this.invMass, this.edgeCompliance, dt);
                    Constraints.solveVolumes(this.pos, this.tetIds, this.invMass, this.restVol, this.volCompliance, dt);
                }
        
                postSolve(dt) {
                    for (let i = 0; i < this.numParticles; i++) {
                        if (this.invMass[i] === 0.0)
                            continue;
                        
                        // XPBD - step 3
                        // calc velocity with current position and previous position                        
                        vecSetDiff(this.vel,i, this.pos,i, this.prevPos,i, 1.0 / dt);
                    }
                }
        
                endFrame() {
                    this.updateTetMesh();
                    this.updateVisMesh();
                }
        
                updateTetMesh() {
                    const positions = this.tetMesh.geometry.attributes.position.array;
                    for (let i = 0; i < this.pos.length; i++)
                        positions[i] = this.pos[i];
                    this.tetMesh.geometry.attributes.position.needsUpdate = true;
                    this.tetMesh.geometry.computeBoundingSphere();
                }
        
                updateVisMesh() {
                    const positions = this.visMesh.geometry.attributes.position.array;
                    let nr = 0;
                    for (let i = 0; i < this.numVisVerts; i++) {
                        let tetNr = this.skinningInfo[nr++] * 4;
                        if (tetNr < 0) {
                            nr += 3;
                            continue;
                        }
                        let b0 = this.skinningInfo[nr++];
                        let b1 = this.skinningInfo[nr++];
                        let b2 = this.skinningInfo[nr++];
                        let b3 = 1.0 - b0 - b1 - b2;
                        let id0 = this.tetIds[tetNr++];
                        let id1 = this.tetIds[tetNr++];
                        let id2 = this.tetIds[tetNr++];
                        let id3 = this.tetIds[tetNr++];
                        vecSetZero(positions,i);
                        vecAdd(positions,i, this.pos,id0, b0);
                        vecAdd(positions,i, this.pos,id1, b1);
                        vecAdd(positions,i, this.pos,id2, b2);
                        vecAdd(positions,i, this.pos,id3, b3);
                    }
                    this.visMesh.geometry.computeVertexNormals();
                    this.visMesh.geometry.attributes.position.needsUpdate = true;
                    this.visMesh.geometry.computeBoundingSphere();
                }
        
                squash() {
                    for (let i = 0; i < this.numParticles; i++) {
                        this.pos[3 * i + 1] = 0.5;
                    }
                    this.endFrame();
                }
            }
        
            document.getElementById("complianceSlider").oninput = function() {
                for (let i = 0; i < gPhysicsScene.objects.length; i++)
                    gPhysicsScene.objects[i].edgeCompliance = this.value * 10.0;
            }
        
            function run() {
                gWorld.run();
            }
        
            function restart() {
                gWorld.restart();
            }
        
            function squash() {
                gWorld.squash();
            }

            function onShowTets() {
                gWorld.onShowTets();
            }

            registerWorld(new SoftBodyWorld(gPhysicsScene, container, true));
            
        </script>
    </body>
</html>