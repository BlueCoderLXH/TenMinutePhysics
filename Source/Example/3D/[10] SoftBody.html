<!DOCTYPE html>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<html lang="en">
    <head>
        <title>Soft Body Simulation</title>
        <style>
            body {
                font-family: verdana, serif;
                font-size: 15px;
            }
            .button {
                background-color: #606060;
                border: none;
                color: white;
                padding: 15px 32px;
                font-size: 16px;
                margin: 4px 2px;
                cursor: pointer;
            }
        </style>
    </head>
    
    <body>
        <h1>Soft Body Simulation</h1>
        <button id = "buttonRun" onclick="run()" class="button">Run</button>
        <button onclick="restart()" class="button">Restart</button>
        <button onclick="squash()" class="button">Squash</button>
        <button onclick="newBody()" class="button">Bodies++</button>&nbsp;&nbsp;
        <br><br>
        <span id = "numTets">0</span> tets&nbsp;&nbsp;
        Compliance:
        <label for="complianceSlider"></label><input type = "range" min = "0" max = "10" value = "0" id = "complianceSlider" class = "slider">
        <br><br>
        <div id="container"></div>
        
        <script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
        <script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
        
        <script src="../../../Engine/Algorithms/MathMethods.js"></script>
        <script src="../../../Engine/Algorithms/Grabber.js"></script>
        <script src="../../../Engine/Physics/Constraints.js"></script>
        <script src="../../../Engine/Framework/PhysicsWorld.js"></script>
        <script src="../../../Engine/Framework/PhysicsObject.js"></script>
        
        <script src="../../GeometryData/[10] SoftBodyData.js"></script>
       
        <script>
            let gPhysicsScene = {
                gravity : [0.0, -10.0, 0.0],
                dt : 1.0 / 60.0,
                numSubsteps : 10,
                paused: true,
                objects: [],
            };
            
            class SoftBodyWorld extends PhysicsWorldBase {
                initPhysics() {
                    let body = new SoftBody(bunnyMesh, this.ThreeScene);
                    this.PhysicsScene.objects.push(body);
                    this.setTargetLayer(SoftBody.Layer);
                    
                    document.getElementById("numTets").innerHTML = body.numTets;
                }

                newBody() {
                    let body = new SoftBody(bunnyMesh, this.ThreeScene);
                    body.translate(-1.0 + 2.0 * Math.random(), 0.0, -1.0 + 2.0 * Math.random());
                    this.PhysicsScene.objects.push(body);

                    let numTets = 0;
                    for (let i = 0; i < this.PhysicsScene.objects.length; i++)
                        numTets += this.PhysicsScene.objects[i].numTets;
                    
                    document.getElementById("numTets").innerHTML = numTets;                    
                }
            }
            
            class SoftBody extends PhysicsObjectGrabable {
                static Layer = 1;
                
                constructor(tetMesh, scene, edgeCompliance = 100.0, volCompliance = 0.0) {
                    super();
                    
                    // physics
                    this.numParticles = tetMesh.verts.length / 3;
                    this.numTets = tetMesh.tetIds.length / 4;
                    this.pos = new Float32Array(tetMesh.verts);
                    this.prevPos = tetMesh.verts.slice();
                    this.vel = new Float32Array(3 * this.numParticles); // velocity for vertex on 3d
        
                    this.tetIds = tetMesh.tetIds;
                    this.edgeIds = tetMesh.tetEdgeIds;
                    this.restVol = new Float32Array(this.numTets);
                    this.edgeLengths = new Float32Array(this.edgeIds.length / 2);
                    this.invMass = new Float32Array(this.numParticles);
        
                    this.edgeCompliance = edgeCompliance;
                    this.volCompliance = volCompliance;
                    
                    this.grads = new Float32Array(4 * 3);
        
                    this.initPhysics();
        
                    // create surface triangle mesh
                    let geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(this.pos, 3));
                    geometry.setIndex(tetMesh.tetSurfaceTriIds);
                    let material = new THREE.MeshPhongMaterial({color: 0x87CEEB});
                    material.flatShading = true;
                    this.surfaceMesh = new THREE.Mesh(geometry, material);
                    this.surfaceMesh.geometry.computeVertexNormals();
                    this.surfaceMesh.userData = this;
                    this.surfaceMesh.layers.enable(SoftBody.Layer);
                    scene.add(this.surfaceMesh);
                }
        
                translate(x, y, z) {
                    for (let i = 0; i < this.numParticles; i++) {
                        vecAdd(this.pos,i, [x,y,z],0);
                        vecAdd(this.prevPos,i, [x,y,z],0);
                    }
                }
        
                updateMeshes() {
                    this.surfaceMesh.geometry.computeVertexNormals();
                    this.surfaceMesh.geometry.attributes.position.needsUpdate = true;
                    this.surfaceMesh.geometry.computeBoundingSphere();
                }
        
                initPhysics() {
                    this.invMass.fill(0.0);
                    this.restVol.fill(0.0);
        
                    // calc inverse mass volume value of tetrahedron
                    for (let i = 0; i < this.numTets; i++) {
                        // here density ρ=1 by default, so that mass equal to volume
                        let density = 1;
                        let vol = Constraints.getTetVolume(this.pos, this.tetIds, i);
                        let mass = vol * density;
                        this.restVol[i] = vol;
                        let inverseMass = mass > 0.0 ? 1.0 / (mass / 4.0) : 0.0;
                        
                        // every single point will link multi tetrahedrons, so add inverse mass value for every point of the tetrahedron 
                        this.invMass[this.tetIds[4 * i]] += inverseMass;
                        this.invMass[this.tetIds[4 * i + 1]] += inverseMass;
                        this.invMass[this.tetIds[4 * i + 2]] += inverseMass;
                        this.invMass[this.tetIds[4 * i + 3]] += inverseMass;
                    }
                    
                    // calc length of edge
                    for (let i = 0; i < this.edgeLengths.length; i++) {
                        let id0 = this.edgeIds[2 * i];
                        let id1 = this.edgeIds[2 * i + 1];
                        this.edgeLengths[i] = Math.sqrt(vecDistSquared(this.pos,id0, this.pos,id1));
                    }
                }

                preSolve(dt, gravity) {
                    for (let i = 0; i < this.numParticles; i++) {
                        // don't need to move for one's mass is infinite
                        if (this.invMass[i] === 0.0)
                            continue;
                        
                        // XPBD - step 1
                        // - calc velocity with g and dt
                        // - save previous position with current
                        // - calc new position with new velocity
                        vecAdd(this.vel,i, gravity,0, dt);
                        vecCopy(this.prevPos,i, this.pos,i);
                        vecAdd(this.pos,i, this.vel,i, dt);
                        
                        // handle down border
                        let y = this.pos[3 * i + 1];
                        if (y < 0.0) {
                            vecCopy(this.pos,i, this.prevPos,i);
                            this.pos[3 * i + 1] = 0.0;
                        }
                    }
                }
        
                solve(dt) {
                    // XPBD - step 2
                    // handle constraints
                    // for 3d model: edge / volume
                    // for 2d: edge
                    // 
                    // one distance constraint per edge
                    // one volume constraint per tetrahedron
                    Constraints.solveEdges(this.pos, this.edgeLengths, this.edgeIds, this.invMass, this.grads, this.edgeCompliance, dt);
                    Constraints.solveVolumes(this.pos, this.tetIds, this.grads, this.invMass, this.restVol, this.volCompliance, dt);
                }
        
                postSolve(dt) {
                    for (let i = 0; i < this.numParticles; i++) {
                        if (this.invMass[i] === 0.0)
                            continue;
                        
                        // XPBD - step 3
                        // calc velocity with current position and previous position
                        vecSetDiff(this.vel,i, this.pos,i, this.prevPos,i, 1.0 / dt);
                    }
                    this.updateMeshes();
                }
        
                squash() {
                    for (let i = 0; i < this.numParticles; i++) {
                        this.pos[3 * i + 1] = 0.5;
                    }
                    this.updateMeshes();
                }
            }
        
            document.getElementById("complianceSlider").oninput = function() {
                for (let i = 0; i < gPhysicsScene.objects.length; i++)
                    gPhysicsScene.objects[i].edgeCompliance = this.value * 50.0;
            }
        
            function run() {
                gWorld.run();
            }
        
            function restart() {
                gWorld.restart();
            }
        
            function squash() {
                gWorld.squash();
            }
        
            function newBody() {
                gWorld.newBody();
            }
        
            registerWorld(new SoftBodyWorld(gPhysicsScene, container, true));
        
        </script>
    </body>
</html>